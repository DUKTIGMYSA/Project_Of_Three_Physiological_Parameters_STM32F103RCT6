/*********************************************************************************************************
* 模块名称：RunClock.c
* 摘    要：RunClock模块
* 当前版本：1.0.0
* 作    者：SZLY(COPYRIGHT 2018 - 2020 SZLY. All rights reserved.)
* 完成日期：2020年01月01日 
* 内    容：
* 注    意：none                                                                  
**********************************************************************************************************
* 取代版本：
* 作    者：
* 完成日期：
* 修改内容：
* 修改文件：
*********************************************************************************************************/

/*********************************************************************************************************
*                                              包含头文件
*********************************************************************************************************/
#include "Pluse.h"
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>  
/*********************************************************************************************************
*                                              宏定义
*********************************************************************************************************/
#define SIZE 300  // 数据数组的大小，根据实际情况调整
#define PEAKS_SIZE 60  // 峰值数组的大小
#define TROUGH_SIZE 60  // 谷值数组的大小
#define THRESHOLD 5 // 差值阈值
#define MAX_VALID_PEAKS 60 // 最大有效峰值数量

/*********************************************************************************************************
*                                              内部变量
*********************************************************************************************************/
/*********************************************************************************************************
*                                              内部函数声明
*********************************************************************************************************/
/*********************************************************************************************************
*                                              内部函数实现
*********************************************************************************************************/
/*********************************************************************************************************
*                                              API函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称：InitPluse
* 函数功能：初始化RunClock模块 
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/
void  InitPluse(void)
{

}

/*********************************************************************************************************
* 函数名称：findPeaks
* 函数功能：波峰和波谷的计算
* 输入参数：
*  			 *src        源数据数组
*       	 src_lenth   源数据数组长度
*   	     distance    峰与峰,谷与谷的搜索间距
*         	 *indMin     找到的谷的index数组
*         	 *indMin_len 数组长度
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：
*********************************************************************************************************/

void find_peaks_and_troughs(const int* data, int size, int* peaks, int* num_peaks, int* troughs, int* num_troughs)
{

    // 初始化计数器
    int i = 0;
    int start = 0;
    int end = 0;
    int middle = 0;
    *num_peaks = 0;
    *num_troughs = 0;


    // 计算峰值
    for (i = 1; i < size - 1; i++)
    {
        // 判断是否为峰值
        if (data[i] > data[i - 1] && data[i] > data[i + 1])
        {
            if (*num_peaks < PEAKS_SIZE)
            {
                peaks[(*num_peaks)++] = i;
            }
        }
        // 判断是否为平顶峰值
        else if (data[i] > data[i - 1] && data[i] == data[i + 1])
        {
            start = i;
            end = i;
            while (end < size - 1 && data[end] == data[end + 1])
            {
                end++; // 跳过平顶的部分
            }
            if (data[end + 1] < data[end])
            {
                middle = (start + end) / 2; // 计算中间值
                if (*num_peaks < PEAKS_SIZE)
                {
                    peaks[(*num_peaks)++] = middle;
                }
            }
            i = end; // 跳过已处理的平顶部分
        }
    }

    // 计算谷值
    for (i = 1; i < size - 1; i++)
    {
        // 判断是否为谷值
        if (data[i] < data[i - 1] && data[i] < data[i + 1])
        {
            if (*num_troughs < TROUGH_SIZE)
            {
                troughs[(*num_troughs)++] = i;
            }
        }
        // 判断是否为平底谷值
        else if (data[i] < data[i - 1] && data[i] == data[i + 1])
        {
            start = i;
            end = i;
            while (end < size - 1 && data[end] == data[end + 1])
            {
                end++; // 跳过平底的部分
            }
            if (data[end + 1] > data[end])
            {
                middle = (start + end) / 2; // 计算中间值
                if (*num_troughs < PEAKS_SIZE)
                {
                    troughs[(*num_troughs)++] = middle;
                }
            }
            i = end; // 跳过已处理的平底部分
        }
    }
}

/*********************************************************************************************************
* 函数名称：GetPluse
* 函数功能：计算波形的频率 
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：先通过波谷计算波形的周期，再将两个波形的周期取平均值
*********************************************************************************************************/      


int GetPulse(int* inRedMax, int* indREDMax_len, int* inRedMin, int* indREDMin_len, int* src)
{
    u16 point = 0; // 周期计数
    u32 red_cyc = 0; // 周期累积
    u16 pulse = 0; // 最终脉冲值
    u16 validPeaksCount = 0; // 有效的峰值数量
    u16 iCnt; // 循环计数器
    u16 Min_len = *indREDMin_len; // 最小值数组长度
    u16 Max_len = *indREDMax_len; // 最大值数组长度

    // 使用静态数组来代替动态分配内存
    // 假设最大有效峰值数量不会超过 MAX_VALID_PEAKS
    u16 validMaxIndices[MAX_VALID_PEAKS];

    // 根据最大值和最小值的相对位置来确定有效峰值
    if (inRedMax[0] < inRedMin[0])
    {
        // 峰值在谷值之前
        for (iCnt = 0; iCnt < Min_len && iCnt < Max_len - 1; iCnt++)
        {
            if (src[inRedMax[iCnt + 1]] - src[inRedMin[iCnt]] > THRESHOLD)
            {
                validMaxIndices[validPeaksCount++] = inRedMax[iCnt + 1]; // 记录有效峰值索引
            }
        }
    }
    else
    {
        // 谷值在峰值之前
        for (iCnt = 0; iCnt < Max_len && iCnt < Min_len; iCnt++)
        {
            if (src[inRedMax[iCnt]] - src[inRedMin[iCnt]] > THRESHOLD)
            {
                validMaxIndices[validPeaksCount++] = inRedMax[iCnt]; // 记录有效峰值索引
            }
        }
    }

    // 根据有效的峰值计算周期
    for (iCnt = 0; iCnt < validPeaksCount - 1; iCnt++)
    {
        red_cyc += (validMaxIndices[iCnt + 1] - validMaxIndices[iCnt]); // 计算周期
        point++; // 增加有效周期计数
    }

    // 防止除以零的错误
    if (point > 0)
    {
        red_cyc /= point; // 计算平均周期
        pulse = (6000 / red_cyc)*13/14; // 计算脉冲
        point = 0;
    }
    else
    {
        pulse = 0;
    }

    return pulse; // 返回计算得到的脉冲值
}

/*********************************************************************************************************
* 函数名称：IIRFilter
* 函数功能：IIR滤波器 
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2018年01月01日
* 注    意：先通过波谷计算波形的周期，再将两个波形的周期取平均值
*********************************************************************************************************/
float filter_1Order(float val)
{
  float a = 0.2452372752528;      // 滤波系数
  float temp_out = 0; // 临时输出变量
  static float last_val = 0;

  temp_out = a * val + (1 - a) * last_val; // 计算滤波后的输出
  last_val = temp_out;                     // 更新上一个输出值

  return temp_out; // 返回滤波后的输出值
}

